{"version":3,"names":["STATEMENT_OR_BLOCK_KEYS","VISITOR_KEYS","isBlockStatement","isExpression","isIdentifier","isLiteral","isStringLiteral","isType","matchesPattern","_matchesPattern","pattern","allowPartial","node","has","key","val","Array","isArray","length","isStatic","scope","is","isnt","equals","value","isNodeType","type","canHaveVariableDeclarationOrExpression","parentPath","isFor","canSwapBetweenExpressionAndStatement","replacement","isArrowFunctionExpression","isCompletionRecord","allowInsideFunction","path","first","container","isFunction","isProgram","isDoExpression","isStatementOrBlock","isLabeledStatement","includes","referencesImport","moduleSource","importName","isReferencedIdentifier","isJSXMemberExpression","property","name","isMemberExpression","isOptionalMemberExpression","computed","object","get","binding","getBinding","kind","parent","isImportDeclaration","source","isImportDefaultSpecifier","isImportNamespaceSpecifier","isImportSpecifier","imported","getSource","end","code","hub","getCode","slice","start","willIMaybeExecuteBefore","target","_guessExecutionStatusRelativeTo","getOuterFunction","getFunctionParent","getProgramParent","isExecutionUncertain","isExecutionUncertainInList","paths","maxIndex","i","parentKey","_guessExecutionStatusRelativeToCached","Map","base","cache","funcParent","this","_guessExecutionStatusRelativeToDifferentFunctionsCached","getAncestry","indexOf","commonPath","commonIndex","Error","divergence","listKey","keys","keyPosition","executionOrderCheckedNodes","Set","_guessExecutionStatusRelativeToDifferentFunctionsInternal","isFunctionDeclaration","isExportDeclaration","id","references","referencePaths","allStatus","childOfFunction","find","isCallExpression","add","status","delete","nodeMap","set","result","resolve","dangerous","resolved","_resolve","push","isVariableDeclarator","constant","ret","isTypeCastExpression","targetKey","toComputedKey","targetName","isObjectExpression","props","prop","isProperty","match","isArrayExpression","isNaN","elems","elem","isConstantExpression","isRegExpLiteral","isTemplateLiteral","every","expression","isUnaryExpression","operator","isBinaryExpression","isInStrictMode","strictParent","sourceType","isClass","body","directive","directives"],"sources":["../../src/path/introspection.ts"],"sourcesContent":["// This file contains methods responsible for introspecting the current path for certain values.\n\nimport type NodePath from \"./index\";\nimport {\n  STATEMENT_OR_BLOCK_KEYS,\n  VISITOR_KEYS,\n  isBlockStatement,\n  isExpression,\n  isIdentifier,\n  isLiteral,\n  isStringLiteral,\n  isType,\n  matchesPattern as _matchesPattern,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n/**\n * Match the current node if it matches the provided `pattern`.\n *\n * For example, given the match `React.createClass` it would match the\n * parsed nodes of `React.createClass` and `React[\"createClass\"]`.\n */\n\nexport function matchesPattern(\n  this: NodePath,\n  pattern: string,\n  allowPartial?: boolean,\n): boolean {\n  return _matchesPattern(this.node, pattern, allowPartial);\n}\n\n/**\n * Check whether we have the input `key`. If the `key` references an array then we check\n * if the array has any items, otherwise we just check if it's falsy.\n */\n\nexport function has<N extends t.Node>(\n  this: NodePath<N>,\n  key: keyof N,\n): boolean {\n  const val = this.node && this.node[key];\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\n/**\n * Description\n */\n\nexport function isStatic(this: NodePath): boolean {\n  return this.scope.isStatic(this.node);\n}\n\n/**\n * Alias of `has`.\n */\n\nexport const is = has;\n\n/**\n * Opposite of `has`.\n */\n\nexport function isnt<N extends t.Node>(\n  this: NodePath<N>,\n  key: keyof N,\n): boolean {\n  return !this.has(key);\n}\n\n/**\n * Check whether the path node `key` strict equals `value`.\n */\n\nexport function equals<N extends t.Node>(\n  this: NodePath<N>,\n  key: keyof N,\n  value: any,\n): boolean {\n  return this.node[key] === value;\n}\n\n/**\n * Check the type against our stored internal type of the node. This is handy when a node has\n * been removed yet we still internally know the type and need it to calculate node replacement.\n */\n\nexport function isNodeType(this: NodePath, type: string): boolean {\n  return isType(this.type, type);\n}\n\n/**\n * This checks whether or not we're in one of the following positions:\n *\n *   for (KEY in right);\n *   for (KEY;;);\n *\n * This is because these spots allow VariableDeclarations AND normal expressions so we need\n * to tell the path replacement that it's ok to replace this with an expression.\n */\n\nexport function canHaveVariableDeclarationOrExpression(this: NodePath) {\n  return (\n    (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor()\n  );\n}\n\n/**\n * This checks whether we are swapping an arrow function's body between an\n * expression and a block statement (or vice versa).\n *\n * This is because arrow functions may implicitly return an expression, which\n * is the same as containing a block statement.\n */\n\nexport function canSwapBetweenExpressionAndStatement(\n  this: NodePath,\n  replacement: t.Node,\n): boolean {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return isExpression(replacement);\n  }\n\n  return false;\n}\n\n/**\n * Check whether the current path references a completion record\n */\n\nexport function isCompletionRecord(\n  this: NodePath,\n  allowInsideFunction?: boolean,\n): boolean {\n  let path = this;\n  let first = true;\n\n  do {\n    const { type, container } = path;\n\n    // we're in a function so can't be a completion record\n    if (!first && (path.isFunction() || type === \"StaticBlock\")) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    // check to see if we're the last item in the container and if we are\n    // we're a completion record!\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while (\n    (path = path.parentPath) &&\n    !path.isProgram() &&\n    !path.isDoExpression()\n  );\n\n  return true;\n}\n\n/**\n * Check whether or not the current `key` allows either a single statement or block statement\n * so we can explode it if necessary.\n */\n\nexport function isStatementOrBlock(this: NodePath): boolean {\n  if (\n    this.parentPath.isLabeledStatement() ||\n    isBlockStatement(this.container)\n  ) {\n    return false;\n  } else {\n    return STATEMENT_OR_BLOCK_KEYS.includes(this.key as string);\n  }\n}\n\n/**\n * Check if the currently assigned path references the `importName` of `moduleSource`.\n */\n\nexport function referencesImport(\n  this: NodePath,\n  moduleSource: string,\n  importName: string,\n): boolean {\n  if (!this.isReferencedIdentifier()) {\n    if (\n      (this.isJSXMemberExpression() &&\n        this.node.property.name === importName) ||\n      ((this.isMemberExpression() || this.isOptionalMemberExpression()) &&\n        (this.node.computed\n          ? isStringLiteral(this.node.property, { value: importName })\n          : (this.node.property as t.Identifier).name === importName))\n    ) {\n      const object = (\n        this as NodePath<t.MemberExpression | t.OptionalMemberExpression>\n      ).get(\"object\");\n      return (\n        object.isReferencedIdentifier() &&\n        object.referencesImport(moduleSource, \"*\")\n      );\n    }\n\n    return false;\n  }\n\n  const binding = this.scope.getBinding((this.node as t.Identifier).name);\n  if (!binding || binding.kind !== \"module\") return false;\n\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  // check moduleSource\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (\n    path.isImportSpecifier() &&\n    isIdentifier(path.node.imported, { name: importName })\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Get the source code associated with this node.\n */\n\nexport function getSource(this: NodePath): string {\n  const node = this.node;\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(